## 1. 데이터베이스

- `RDBMS vs Nosql`의 차이점은?
    - RDBMS는 스키마에 맞추기 때문에 데이터를 관리하기 편하고 정합성을 보장할 수 있으나, 시스템이 커질수록 쿼리가 복잡해지고 수평적 확장이 어렵습니다.
    - Nosql은 스키마 없이 key-value 형태로 저장되며, 데이터의 중복이 허용되기 때문에, 이에 대한 관리가 필요합니다. 

- `트리거(Trigger)`란?
    - 데이터베이스 혹은 테이블에 연결되어 이벤트(insert, update, DELETE 등)를 수신하면 자동으로 동작하는 프로그램입니다. 
    - 변경에 민감한 테이블에 대한 변경 감시 및 로깅이나 간단한 검증 및 수정을 위해 실행됩니다.
    - 다만, 트리거의 수가 너무 많거나, 함수 코드가 너무 복잡하거나, 재귀 순환 하는 등의 문제점에 주의해야합니다.
    - ex) postgresql
    ```sql 
      CREATE OR REPLACE TRIGGER 트리거_이름  
      { BEFORE | AFTER | INSTEAD OF }     -- 트리거 실행 시점
      { DML이벤트 [ OR DML이벤트 ... ] }     -- 트리거 이벤트 (INSERT or UPDATE or DELETE ..)
      ON 트리거를_적용시킬_테이블_또는_뷰_이름
      FOR EACH { ROW | STATEMENT } 		-- 트리거 실행범위 ( 각행 또는 한번만 )
      [WHEN (조건)] 						-- 트리거 실행 조건( EACH ROW 일 때 조건에 만족하는 행만 수행가능 )
      EXCUTE { FUNCTION | PROCEDURE } 함수명("문자열_상수_파라미터");
    ```
    - 트리거는 어떤 경우에 사용하면 좋을까요?
        - 데이터 무결성을 유지하고 싶을 때, 반복적인 데이터베이스 작업을 자동화하고 싶을 때 사용합니다.
    - 트리거를 사용할 때 주의해야 할 점은 무엇인가요?
        - 트리거로 인해 데이터베이스의 복잡성이 증가하지 않도록 주의해야 하며, 성능 저하를 초래하지 않도록 설계해야 합니다.

- `트랜잭션(Transaction)`이란? 
    - 원자적으로 분리할 수 없는 작업의 최소 단위
    - 트랜잭션이 안정적으로 수행되고 데이터의 일관성을 유지하기 위한 특성들이 있습니다. 이것을 ACID 성질이라고하며 다음과 같습니다.
        - 원자성(Atomicity): 트랜잭션 내의 모든 작업은 전부 실행되거나 전혀 실행되지 않아야 합니다.
        - 일관성(Consistency): 트랜잭션은 유효성을 갖춘 데이터베이스 상태를 다른 유효한 상태로 변환합니다.
        - 고립성(Isolation): 동시에 여러 트랜잭션이 수행될 때 각각의 트랜잭션이 독립적으로 실행된 것처럼 보장해야 합니다.
        - 지속성(Durability): 성공적으로 수행된 트랜잭션은 시스템에 오류가 발생해도 변경사항이 데이터베이스에 영구적으로 반영되어야 합니다.
    - 여러 트랜잭션이 동시에 이루어질 때 데이터의 무결성을 보장하기 위해 격리 수준(Isolation levels)이 필요합니다. 격리 수준에는 여러 종류가 있으며, 격리 수준이 낮을수록 동시성이 증가하지만 다양한 문제가 발생할 수 있습니다.
        - READ UNCOMMITTED: 가장 낮은 격리 수준으로, 다른 트랜잭션이 커밋하지 않은 데이터를 읽을 수 있습니다.
        - READ COMMITTED: 커밋된 데이터만 읽을 수 있으므로 일관성 없는 데이터를 읽는 현상은 방지하지만, Non-Repeatable Read는 발생할 수 있습니다.
        - REPEATABLE READ: 트랜잭션이 시작되었을 때의 데이터를 일관되게 조회할 수 있으나, Phantom Read가 발생할 수 있습니다.
        - SERIALIZABLE: 가장 높은 격리 수준으로, 완벽한 일관성을 보장합니다. 그러나 동시성이 크게 저하됩니다.
    - 트랜잭션을 사용할 때 주의해야 할 점은 무엇인가요? 
        - 트랜잭션을 사용할 때는 데드락을 주의해야 하고, 가능한 짧은 시간 내에 완료되도록 설계하는 것이 좋습니다. 또한 격리 수준에 따른 문제점을 이해하고 적절한 수준 설정이 필요합니다.
    - 격리 수준 중 SERIALIZABLE에 대해 설명해주세요. 
        - SERIALIZABLE은 트랜잭션들이 순차적으로 실행되는 것처럼 일관성을 완벽하게 보장하는 가장 높은 격리 수준입니다. 동시성이 저하되는 단점이 있으나, 데이터베이스의 일관성과 무결성을 최대한 보장받을 수 있습니다.

- `인덱스(Index)`란?
    - 데이터 검색 속도를 높이기 위해 사용되는 데이터 구조
    - 인덱스의 장/단점 
        - 장점 👍
            - 검색 속도 향상: 인덱스를 사용하면 데이터 검색과 조회 작업이 빨라집니다.
            - 정렬 및 그룹화 작업 최적화: 인덱스가 적용된 컬럼을 기반으로 정렬(ORDER BY)이나 그룹화(GROUP BY)를 할 때 성능이 향상됩니다.
            - 조인 성능 향상: 인덱스를 사용하여 다른 테이블과의 조인(Join) 작업이 최적화됩니다.
        - 단점 👎
            - 인덱스 관리 비용: 인덱스를 생성하고 유지하기 위해 추가적인 저장 공간이 요구됩니다.
            - 데이터 변경 성능 저하: 삽입(INSERT), 삭제(DELETE), 수정(UPDATE) 작업 시 인덱스의 재구성이 필요하여, 이로 인한 성능 저하가 발생할 수 있습니다.
    - ex) `CREATE INDEX idx_column ON table_name (column_name);`

- 1,2,3 정규화에 대해 설명하시오.

- 정규화의 장/단점은?
    - 장점 👍
        - 데이터베이스 변경시 이상현상(삽입, 갱신, 삭제)을 방지할 수 있다.
        - 데이터베이스 구조 확장시 일부만 변경하면 된다.
    - 단점 👎
        - join 연산이 많아져, 성능이 저하될 수 있다.

- SQL Injection이란?
    - 악의적으로 SQL 구문을 삽입하여 데이터베이스를 비정상적으로 조작하는 공격 기법
    - 입력값을 검증하거나 저장 프로시저를 사용

- `DB Lock`이란?
    - 데이터베이스에서 '락'이란 동시에 여러 트랜잭션이 데이터에 접근할 때 발생할 수 있는 데이터의 불일치 문제를 방지하기 위해 사용하며, 특정 데이터 항목에 대한 접근을 제어하는 메커니즘입니다. 락는 데이터를 안전하게 보호하고, ACID 원칙(원자성, 일관성, 독립성, 지속성)을 유지하는 데 핵심적인 역할을 합니다.
    - 예상 질문 1: 데이터베이스에서 락이 왜 필요한가요?
        - 예시 답변: 데이터베이스에서 락은 데이터의 일관성과 정확성을 유지하는 데 필요합니다. 동시에 여러 트랜잭션이 동일한 데이터에 액세스할 때 발생할 수 있는 문제들, 예를 들어 '갱신 손실', '더티 리드', '언리피트 릴드' 등을 방지하기 위해 락 기능이 필요합니다. 락을 통해 데이터의 동시성 제어가 가능하여, ACID 원칙을 준수할 수 있습니다.

    - 예상 질문 2: 데드락은 무엇이며, 어떻게 방지할 수 있나요?
        - 예시 답변: 데드락은 여러 트랜잭션이 서로 필요로 하는 락을 보유하고 있어, 무한히 대기하는 상태를 말합니다. 다시 말해, 각 트랜잭션이 서로의 락 해제를 기다리는 교착 상태에 빠지는 것입니다. 이를 방지하기 위해 데이터베이스 시스템은 데드락 탐지 알고리즘을 사용하여 교착 상태를 파악하고, 일부 트랜잭션을 중단시켜 시스템이 계속 동작할 수 있도록 합니다. 예를 들어, 타임아웃을 설정하여 일정 시간동안 대기하는 트랜잭션이 있으면, 그 트랜잭션을 강제로 종료할 수도 있습니다.

    - 예상 질문 3: 공유락과 배타락의 차이점에 대해 설명해주세요.
        - 예시 답변: 공유락은 여러 트랜잭션이 동시에 같은 데이터를 읽을 수 있도록 하는 락입니다. 반면, 배타락은 특정 트랜잭션이 데이터에 대해 쓰기 작업을 할 때 사용되며, 해당 트랜잭션이 데이터를 읽고 쓰는 동안 다른 어떤 트랜잭션도 해당 데이터에 접근할 수 없도록 합니다. 결과적으로 공유락은 동시 읽기를 허용하지만 쓰기는 금지하고, 배타락은 해당 데이터에 대한 모든 액세스를 독점합니다.

    - 예상 질문 4: 잠금 단위에 대해 설명할 수 있나요?
        - 예시 답변: 잠금 단위는 락이 적용되는 데이터 양을 나타내며, 대규모, 중규모, 소규모 잠금으로 나눌 수 있습니다. 대규모 잠금은 테이블 전체에 락을 적용하는 것을 말하며, 중규모 잠금은 특정 포션에, 소규모 잠금은 특정 행에만 락을 적용하는 것입니다. 잠금 단위는 락이 걸리는 범위를 조절함으로써 시스템의 동시성과 성능을 최적화하는 데 중요한 역할을 합니다.

- `옵티마이저(Optimizer)`란?
    - 옵티마이저란 데이터 베이스 관리 시스템(DBMS) 내에서 최적의 쿼리 수행 경로를 결정하는 구성 요소입니다. 비용 기반 옵티마이저는 다양한 실행 경로의 비용을 평가하여 가장 낮은 비용을 가지는 실행 경로를 선택하는 반면, 규칙 기반 옵티마이저는 미리 정의된 규칙들을 기준으로 실행 경로를 선택합니다.
    - 옵티마이저의 작동 원리
        - 쿼리 파싱: 입력 받은 SQL 쿼리가 문법적으로 올바른지 검사하고, 이해할 수 있는 형태로 변환합니다.
        - 쿼리 최적화: 가능한 많은 쿼리 실행 경로를 생성하고, 그 중에서 최적의 실행 계획을 선택합니다.
        - 쿼리 실행: 최적화된 실행 계획을 바탕으로 실제 데이터를 조작하며 쿼리를 실행합니다.
        옵티마이저가 고려하는 요소들:
    - 쿼리 최적화 과정에서 옵티마이저가 고려하는 요소들은 아래와 같습니다:
        - 통계 정보: 테이블 크기, 카디널리티(열 값의 고유성), 인덱스의 유무 및 종류 등
        - 쿼리의 종류: Select, Insert, Update, Delete 각각에 대한 다른 최적화 전략이 적용됩니다.
        - 시스템 자원: 현재 시스템의 디스크 I/O, 메모리, CPU 사용량과 예측
        - 실행 비용: 쿼리 실행에 필요한 비용을 예측하는 여러 모델을 사용합니다.
    - 옵티마이저 성능 향상을 위한 팁:
        - 정기적인 통계 업데이트: 옵티마이저가 올바른 결정을 내리기 위해 최신의 통계 정보를 유지하는 것이 중요합니다.
        - 적절한 인덱싱: 특정 쿼리에 대해 적절한 인덱스를 생성하면 쿼리 성능이 대폭 향상됩니다.
        - 쿼리의 단순화: 복잡한 쿼리를 간단하게 바꾸거나, 불필요한 조인을 제거하여 성능을 개선할 수 있습니다.
        - 파라미터 활용: 쿼리 계획을 재사용하게 하기 위한 바인드 변수의 사용은 옵티마이저의 작업 부하를 줄입니다.

- `DB 튜닝`이란?
    - SQL 튜닝 : SQL 튜닝은 데이터 검색, 삽입, 수정, 삭제 작업의 효율을 높이기 위해 SQL 쿼리를 최적화하는 방법입니다.
    - 서버 튜닝 : 서버 튜닝은 데이터베이스 서버의 하드웨어나 DBMS 설정을 조정하여 성능을 향상시키는 방식입니다.
        - 메모리 할당
        - 캐시 사이즈 조정
        - 동시 연결 세션 수 조정
        - 디스크 I/O 최적화
    - 스키마 튜닝 : 스키마 튜닝은 데이터베이스의 물리적 구조인 테이블과 인덱스의 설계를 최적화하는 것을 의미합니다.
        - 정규화를 통한 데이터 중복 최소화
        - 인덱스 설계 최적화
    - 데이터베이스 튜닝이 왜 중요한가요?
        - 데이터베이스 튜닝은 시스템의 전체적인 성능을 좌우하기 때문에 매우 중요합니다. 쿼리의 응답 시간을 줄이고, 시스템 리소스를 효율적으로 사용하여 사용자 만족도를 향상시킬 수 있습니다.
    - SQL 튜닝 시 주의해야 할 점은 무엇인가요?
        - SQL 튜닝 시 주의해야 할 점은 단순히 쿼리 실행 시간만 줄이는 것에 집중하는 것이 아니라, 전체 시스템 성능에 미치는 영향을 고려해야 한다는 것입니다. 또한, 인덱스를 남용하게 되면 갱신 속도가 저하되므로 적절한 수준에서 인덱스를 사용하는 것이 중요합니다.
    - 인덱스는 어떻게 효율적으로 사용할 수 있나요?
        - 인덱스는 검색 속도를 크게 개선할 수 있는 도구이지만, 모든 컬럼에 인덱스를 설정하는 것은 적절하지 않습니다. 데이터의 크기, 업데이트 빈도, 검색 패턴 등을 고려하여 중요하고 자주 검색되는 컬럼에 인덱스를 설정해야 합니다. 또한, 여러 컬럼을 조합한 복합 인덱스를 활용하는 것도 좋은 방법입니다.
    - 데이터베이스 성능을 모니터링하는 도구는 무엇이 있나요?
        - 데이터베이스 성능 모니터링 도구로는 Oracle Enterprise Manager, MySQL Workbench, SQL Server Management Studio 등이 있습니다. 이러한 도구들을 사용하여 실시간으로 성능을 모니터링하고 문제를 식별하여 조정할 수 있습니다.

- 클러스터링과 리플리케이션의 차이?
    - 클러스터링과 리플리케이션의 주요 목적을 설명해보세요.
        - 클러스터링은 주로 시스템의 가용성을 높이고, 여러 하드웨어 리소스 간에 작업을 분산시키기 위해 사용됩니다. 반면 리플리케이션은 데이터의 안정성과 가용성을 높이기 위한 수단으로, 주로 백업이나 데이터베이스 서버 간의 데이터 동기화에 쓰입니다.
    - 데이터베이스 클러스터링 시 발생할 수 있는 문제는 무엇이 있나요?
        - 클러스터링 환경에서는 노드 간의 동기화 문제, 트랜잭션 관리의 어려움, 복잡한 인프라 관리 등이 발생할 수 있습니다. 또한 클러스터 내의 각 노드들은 지속적인 통신과 데이터 동기화가 필요하기 때문에 네트워크 지연과 같은 문제도 있을 수 있습니다.
    - 리플리케이션에서 마스터-슬레이브 구조와 피어 투 피어 구조의 차이점은 무엇인가요?
        - 마스터-슬레이브 구조는 한 데이터베이스 서버가 마스터 역할을 하고 다른 하나 이상의 서버가 슬레이브 역할을 하여 마스터의 데이터를 복사하는 구조입니다. 이 때, 쓰기 작업은 마스터에서만 이루어지고, 슬레이브는 읽기 전용으로 사용됩니다. 반면 피어 투 피어 구조는 모든 노드가 동등한 역할을 하여 쓰기와 읽기 작업 모두를 처리할 수 있습니다. 이는 데이터의 일관성 유지에 더 많은 노력이 필요합니다.

- `파티셔닝`과 `샤딩`이란?

- `뷰(view)`란?
    - 데이터베이스에 저장된 데이터의 하나 이상의 테이블에서 유도된 결과 테이블로, 특정 사용자나 응용 프로그램에 맞게 데이터를 제공하는 가상 테이블입니다.
    - 장점 👍
        - 뷰를 통해 데이터 접근을 제어함으로써 보안을 강화할 수 있다.
        - 복잡한 쿼리를 단순화함으로써 데이터 관리가 용이하다.
        - 기본 테이블의 구조 변경에도 쿼리 수정 없이 뷰를 사용할 수 있다.
    - 단점 👎
        - 뷰를 통한 데이터를 수정하는 것이 제한될 수 있다.
        - 성능 문제가 발생할 수 있다(뷰를 통한 쿼리가 상대적으로 많은 자원을 사용하기 때문).
        - 뷰를 업데이트하는 것이 항상 가능하지 않다.
    - 뷰와 테이블의 차이점은 무엇인가요?
        - 테이블은 데이터의 실제 저장소이며, 레코드와 열로 구성됩니다. 반면에, 뷰는 하나 이상의 테이블에서 선택적인 열과 행을 포함하는 가상 테이블입니다.
    - 뷰를 사용하는 이유는 무엇인가요?
        - 뷰를 사용하면 사용자가 데이터에 접근하는 방법을 제어하고 데이터에 대한 간단한 인터페이스를 제공할 수 있습니다. 또한, 복잡한 쿼리를 간소화하고 보안을 강화할 수 있습니다.
    - 뷰가 데이터베이스 성능에 미치는 영향은 무엇인가요?
        - 뷰는 성능에 영향을 미칠 수 있습니다. 특히, 뷰가 복잡한 쿼리나 많은 조인을 포함할 경우 성능 저하가 발생할 수 있습니다. 그러나 잘 설계된 뷰는 오히려 성능을 향상시킬 수 있습니다.
    - 물리적인 저장이 없는 뷰는 어떻게 데이터를 제공할 수 있나요?
        - 물리적인 저장이 없는 뷰는 쿼리 실행 시점에 기본 테이블의 데이터를 가져와서 가상으로 생성됩니다. 따라서 실제 데이터를 저장하는 것이 아니라 쿼리 결과를 생성하는 방식으로 데이터를 제공합니다.
    - 뷰를 업데이트하는 것이 언제 가능하고, 언제 불가능한가요?
        - 대부분의 데이터베이스 시스템에서 뷰는 기본 테이블의 데이터를 간접적으로 참조하기 때문에 뷰를 업데이트하는 것은 특정 제약 사항을 따릅니다. 예를 들어, 뷰가 여러 테이블을 조인한 결과인 경우 업데이트가 불가능할 수 있습니다. 뷰를 업데이트할 수 있는 경우에는 해당 뷰의 정의에 따라 가능합니다.

- `PK와 FK`에 대해 설명하시오.
    - 기본키(PK)는 테이블 내에 존재하는 각각의 레코드를 고유하게 식별할 수 있는 필드를 말합니다. 기본키는 중복값을 허용하지 않으며, NULL 값도 가질 수 없습니다. 대부분의 경우, 기본키는 테이블의 구조를 정의할 때 설정되며, 데이터베이스의 무결성을 유지하는 데 핵심적인 역할을 합니다.
    - 외래키는 다른 테이블의 기본키를 참조하는 필드입니다. 외래키의 주된 목적은 테이블 간의 관계를 설정하고, 참조 무결성을 유지하는 것입니다. 즉, 외래키의 값은 반드시 다른 테이블의 기본키 값 중 하나와 일치해야 합니다.
    - 대체키(Alternate Key)
        - 대체키는 기본키로 선택될 수 있으나, 선택되지 않은 키를 의미합니다. 이들 키 또한 레코드를 유일하게 식별할 수 있는 속성이지만 기본키로는 사용되지 않습니다.
    - 후보키(Candidate Key)
        - 후보키는 기본키로 사용될 수 있는 속성들의 집합입니다. 이들은 유일성과 최소성을 만족해야 하는데, 즉 테이블에서 레코드를 고유하게 식별할 수 있고, 불필요한 속성을 포함하지 않아야 합니다.
    - 유니크 키(Unique Key)
        - 유니크 키는 모든 레코드에 대해 유일한 값을 가져야 합니다. NULL 값을 제외하고는 중복된 값을 허용하지 않으며, 하나의 테이블에 여러 개의 유니크 키를 설정할 수 있습니다.
    - 복합키(Composite Key)
        - 복합키는 두 개 이상의 필드를 결합하여 테이블 내에서 레코드를 유일하게 식별할 수 있는 키입니다. 복합키는 단일 키만으로는 유일성을 보장하지 못할 때 사용합니다.
    - 인조키(Artificial Key)/서로게이트 키(Surrogate Key)
        - 인조키 또는 서로게이트 키는 비즈니스 의미를 갖지 않는 일련번호나 자동 생성 값 등을 이용하여 생성된 키입니다. 이 키는 데이터 모델링 시에 자주 사용되며, 기본키로 적합하지 않은 복잡한 자연 키 대신 사용됩니다.

- `저장 프로시저(SP)`란 무엇인가?
    - 쿼리들을 함수처럼 실행하기 위해 만들어놓은 쿼리 집합
    - 저장 프로시저는 한 번 실행되면, 캐시에 남아 재차 실행할 때 속도가 빠르다.
    - 유지보수 할 때 프로시저만 수정하면 돼서 편하다. 
    - 사용자에게 테이블 자체가 아닌 저장 프로시저에 접근할 수 있도록 하면 보안이 강화된다. 
    - ex) 
    ```sql
    CREATE PROCEDURE GetCustomerOrders 
        @CustomerId INT
    AS
    BEGIN
        SELECT * FROM Orders 
        WHERE CustomerId = @CustomerId;
    END;

    EXEC GetCustomerOrders @CustomerId = 1;
    ```
    - 올바른 저장 프로시저를 위한 팁
        - 가능한 한 데이터베이스 내 로직을 단순하게 유지하세요.
        - 복잡한 연산은 애플리케이션 레벨에서 처리하는 것이 좋을 수 있습니다.
        - 재사용성과 모듈성을 높이기 위해 매개변수를 올바르게 사용하세요.
        - 저장 프로시저 내부에서는 명확한 트랜잭션 관리가 필요합니다.

- 데이터베이스 무결성이란?
    - 개체 무결성(엔티티 무결성) 개체 무결성은 데이블의 기본 키와 관련된 무결성 규칙으로, 모든 테이블의 기본 키가 유일하며 NULL이 될 수 없도록 확보하는 것을 말합니다. 이는 데이터의 고유성을 보장하기 위해 필수적인 규칙입니다.
    - 참조 무결성(외래 키 무결성) 참조 무결성은 테이블 간의 관계를 나타내는 외래키 관계에 있어, 참조되는 테이블의 기본 키가 수정되거나 삭제될 경우 참조하는 테이블의 외래 키도 영향을 받는 것을 관리하는 무결성입니다.
    - 도메인 무결성 도메인 무결성은 필드의 유효한 범위, 타입, 형식을 지정하여, 데이터의 일관성과 정확성을 보장하는 것입니다. 예를 들어 성적을 입력하는 필드에는 0과 100 사이의 값만 허용하는 것이 도메인 무결성의 예시입니다.
    - 사용자 정의 무결성 사용자 정의 무결성은 특정 비즈니스 규칙에 맞춰 데이터가 유지되어야 할 규칙들을 사용자가 정의하는 무결성입니다. 예를 들면, 어떤 회사는 직원 ID가 특정 형태를 취해야 할 수 있습니다.

## 2. SQL

- 데이터베이스 언어의 종류는?
    - DDL(Definition) : 데이터베이스 구조를 정의, 삭제, 수정하는 언어
        - ex) create, alter, DROP
    - DML(Manipulation) : 자료 검색, 삽입, 갱신, 삭제를 위한 언어
        - ex) select, insert, update, DELETE
    - DCL(Control) : 데이터에 대해 무결성, 병행 수행, 제어, 보호, 관리를 위한 언어
        - ex) commit, rollback, grant, revoke

- `join`의 종류는?
    - `natural join` 
        - 두 테이블에서 동일한 컬럼명을 갖는 컬럼이 모두 조인됩니다. 컬럼명과 타입이 완전히 일치해야 합니다. 
    - `cross join` 
        - 모든 경우의 수를 표현해주는 조인 방식. 
    - `self join` 
        - 자기 자신을 조인 하는 방식. 하나의 테이블을 여러번 복사해서 조인합니다. 
    - `nested loop join` 
        - outer table의 한 row와 매칭되는 inner table의 row를 찾기 위해 반복적으로 조건에 부합하는 row들을 찾는 조인
        - outer table은 추출 건수가 적은 테이블로 설정해야 하며, inner table의 조인 조건 컬럼엔 인덱스가 걸려있어야 성능이 보장됩니다. 다만, 인덱스에 의한 랜덤 액세스에 기반하기 때문에 대량의 데이터 처리시에는 적합하지 않으며, 인덱스 구성 전략이 특히 중요합니다. 
    - `sort merge join` 
        - 두 테이블의 조인 컬럼의 값을 기준으로 각 테이블을 정렬한 후 작은 값부터 조인하는 방법
        - PGA(Private Global Area : Oracle) : 데이터베이스에 접근하는 모든 사용자에게 할당되는 각각의 서버 프로세스가 독자적으로 사용하는 오라클 메모리 영역.
    - `hash join`
        - 대용량 테이블을 조인하는 배치 처리에 용이
        - hash table은 PGA에 존재 -> 처리 속도가 빠름
        - 조인 컬럼을 기준으로 hash function이 적용
        - 랜덤 엑세스 부하가 없다.
        - hash 영역에 들어가는 테이블이 충분히 작아야 유리(너무 크면 디스크 영역을 사용해버림)
        - OLTP에서 해시 조인이 사용되면 CPU나 메모리 사용량이 늘어나기 때문에 수행계획을 살펴서 다른 방식으로 조인하게 해야함.
    - `nested loop join` vs `sort merge join` vs `hash join`
        |조인 방법|테이블 용량|조인 컬럼 인덱스|랜덤 액세스|중요한 점
        |------|---|---|---|---|
        |nested loop join|작을 때|O|O|인덱스 구성 전략|
        |sort merge join|클 때(단, 두 테이블의 크기의 차이가 크지 않을 때)|X|X|조인할 테이블이 이미 정렬되어 있거나 조인 조건이 비교 연산일 때 유리|
        |hash join|클 때|X|X|배치 처리에 용이|
    - 조인 사용 시 고려사항
        - 성능: 조인이 많은 쿼리는 성능 저하를 일으킬 수 있으므로, 필요한 데이터만 정확하게 조인하는 것이 중요합니다.
        - NULL 처리: OUTER JOIN을 사용할 때는 누락된 데이터(즉, NULL 값)를 어떻게 처리할지 고려해야 합니다.
        - 조인 순서: 다수의 테이블을 조인할 때는 조인하는 순서가 성능에 영향을 줄 수 있으므로, 실행 계획을 확인하는 것이 좋습니다.

- MySQL에서 `Full Outer Join` 하는 방법은?
    - `Left Join`과 `Right Join`을 `Union`

- `DROP`, `TRUNCATE`, `DELETE`의 차이점은?
    - `DROP`
        - 테이블 자체와 그 구조를 데이터베이스에서 완전히 제거함.
        - 관련된 인덱스와 트리거, 권한 등도 함께 제거됨.
        - 실행 취소가 불가능함.
        - TRUNCATE와 마찬가지로 조건부 삭제는 불가능함.
    - `TRUNCATE`
        - 테이블에서 모든 행을 빠르게 삭제함.
        - 조건부 삭제는 불가능하며, WHERE 절을 사용할 수 없음.
        - 인덱스도 삭제
        - 트랜잭션 로그를 거의 발생시키지 않음 (일부 DBMS에서 ROLLBACK 가능).
        - 자동 증가하는 필드의 카운터를 리셋함.
    - `DELETE`
        - 하나 이상의 행을 조건부로 삭제할 수 있음.
        - WHERE 절을 통해 특정 데이터를 선택적으로 삭제할 수 있음.
        - 트랜잭션의 일부이며, 실행 취소가 가능함 (ROLLBACK 지원).
        - 상대적으로 느린 성능을 가짐(트랜잭션 로그 발생).

- `HAVING`절에 사용될 수 있는 집계 연산은?
    - count, sum, avg, max, min 등

- `WITH` 절이란?
    - 서브쿼리 대신 재사용 가능한 공통 테이블 표현식(CTE)를 정의하는 방법
    - ex) 
    ```sql
        WITH [cte_name] AS (
        SELECT [column_name(s)]
        FROM [table_name]
        WHERE [condition]
        )

        SELECT [column_name(s)]
        FROM [table_name]
        JOIN [cte_name] ON [join_condition]
        WHERE [condition];
    ```

- `UNION`과 `UNION ALL`의 차이점은?
    - `UNION`은 기본적으로 중복 제거, `UNION ALL`이 중복 허용
    - 컬럼의 개수와 순서과 모든 쿼리에서 동일해야함.
    - 데이터 타입이 같아야 함. 

- `COUNT` 함수
    - `count(*)`, `count(1)` : null 포함
    - `count(컬럼명)` : null 제외
    - `count(distinct 컬럼명)` : null 제외 + 유니크값
    - `select if([조건], [valIfTrue], [valIfFalse])` : 조건에 맞는 값은 valIfTrue로, 그 외는 valIfFalse로
        - postgresql에는 없기 때문에 그 때는 case when 사용 

- `NULL` 처리
    - `IFNULL(컬럼명, 값)`, `ISNULL(컬럼명, 값)`, `NVL(컬럼명, 값)` : 해당 필드의 값이 null인 경우, `값`으로 반환
    - `NULLIF(값1, 값2)` : 값1 == 값2 면 null. 다르면 값1. 
    - `COALESCE(값1, 값2)` : 값1이 null이면 값2, 값2도 null이면 null로 반환

- 데이터 타입 변환
    - `CAST(값 AS 바꿀 데이터 타입)`, `::` : 모든 데이터 타입으로 변환 가능
    - `CONVERT(숫자형, 값)` : 문자->숫자로 형변환 할 때 사용. 숫자형에는 주로 `numeric`이나 `decimal`이 들어감.

- `CTAS`란? 
    - 새로운 테이블을 생성할 때 기존의 테이블의 컬럼 속성과 데이터를 모두 똑같이 복사하여 만들 때 사용.
    - ex) `CREATE TABLE 테이블명 AS SELECT * FROM 테이블명`
    - 같은 형식의 테이블은 만들되, 데이터는 복사하지 않는 경우
    - ex) `CREATE TABLE 테이블명 AS SELECT * FROM 테이블명 where 1=0;`

- 문자열 처리
    - SUBSTRING (문자열, 시작위치, 개수) : 시작위치 만큼 해서 개수까지 가능
    - LEFT(문자열, 개수) : 문자열 중 왼쪽 개수 출력
    - RIGHT(문자열, 개수) : 문자열 중 오른쪽 개수 출력

- 숫자 처리
    - ROUND : 반올림 (자릿수 설정 가능)
    - TRUNCATE :  내림 (자릿수 설정 가능)
    - CEILING : 소숫점 올림(자릿수 설정 불가능)
    - FLOOR : 소숫점 버림 (자릿수 설정 불가능)